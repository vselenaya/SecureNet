# Реализация защищённого шифрованного канала связи между клиентом и сервером

#### Общее описание:
Данный проект представляет собой реализацию клиентского и сервервного приложений, который обмениваются сообщениями, вводимыми с клавиатуры. Всё общение происходит по защищённому каналу связи (обеспечивается как аутентификация, так и шифрование и целостность).\
Дополнительно реализовано приложение для атаки Man-in-the-middle (человек посередине) на имеющуюся клиент-серверную архитектуру.

#### Цели проекта:
Ознакомиться с практическими методами шифрования и защиты данных, освоить навык написания клиент-серверных приложений и работы с сокетами.

#### Реализация проекта представлена в двух видах:
1. С помощью протокола TLS библиотеки *openssl*. Поддерживатся использование серверного сертификата.
2. Более низкоуровневая реализация, где весь протокол установления защищённого канала связи и шифрования данных написан вручную с помощью криптографических методов библиотеки *libcrypto*.



Требования для использования:\
Операционная система Linux, библиотека *openssl* (при написании использовалась версия )\
\
Далее будут подробно описаны обе реализации.



## Реализация при помощи TLS
Реализация находится в директории `tls`. В директории находится `Makefile` для сборки проекта через утилиту *make*. 

#### Быстрый старт:
Для тех, кому лень читать подробно, кратко тут:
1. Сгенерировать сертификат и закрытый ключ сервера: `make cert_server`
2. Команда `make project` создаёт 3 программы: `client` и `server` -- это клиент и сервер, а также `mim` - программа для атаки MIM.
3. Для обычного защищённого общения нужно запустить сначала сервер: `./server`, а потом клиент: `./client`
4. Для тестирования скорости работы, запускаем `./server test_speed`, а потом `./client test_speed`
5. Для демонстрации атаки MIM, нужно сгенерировать сертификат и закрытый ключ приложения mim -- это делается через `make cert_mim`, а потом подменить в коде клиента порт и сертификат сервера на соотвествующее у mim. Далее запускаем в порядке: `./server`, `./mim`, `./client`.

#### Структура проекта:
```
├── include/                # Директория с заголовочными файлами
    └── common.h        
├── src/                    # Директория с исходным кодом
    ├── client.c            # Код клиентского приложения
    ├── server.c            # Код серверного приложения
    ├── mim.c               # Код приложения для атаки MIM
    └── common.c            # Общие функции
├── obj/                    # Директория c объектными файлами
    ├── client.o
    ├── server.o
    ├── mim.o
    └── common.o
├── client                  # Три исполняемых файла: клиент, сервер и приложение mim
├── server
├── mim
├── mim_cert.pem            # Файл сертификата приложения mim
├── mim_cert.pem            # Файл закрытого ключа приложения mim
├── mim_cert.pem            # Файл сертификата сервера
├── mim_cert.pem            # Файл закрытого ключа сервера
└── Makefile                # Файл для сборки проекта через утилиту make
```
Изначально в проекте директории `obj/` и файлов `client`, `server`, `mim` нет: они появится после сборки проекта через `Makefile`.\
Файлы сертификатов и закрытых ключей тоже нужно генерировать через `make`.


#### Общая идея:
Клиент подключается к северу по обычному TCP-соединению. Далее поверх этого соединения используется TLS-протокол, через который происходит аутентификация сервера (с помощью сертификата), а также обмен сообщениями (конфиденциальность и целостность протокол TLS обеспечивает). Сообщения клиент и сервер по очереди вводят с клавиатуры.

Чтобы клиент мог убедиться, что он действительно общается с настоящим сервером (то есть, что никто не перехватил соединение и не притворяется сервером), сервер должен подтвердить свою подлинность (это называется аутентификация). В протоколt TLS это делается с помощью *сертификата* -- специального файла, состоящего из некоторого описания сервера (например, его имени url и открытого ключа) и подписи этого описания.\
Тогда клиент, получая такой сертификат, проверяет подпись и, если она правильная, то клиент может быть уеверн в достоверности открытого ключа сервера, находящегося в сертификате. А зная открытый ключ, можно проверить, что тот, с кем клиент общается, является обладателем парного зарытого ключа (тут везде используется криптография с парой открытый-закрытый ключ) -- например, просто получить случайный текст и его подпись от сервера. Короче, протокол TLS всё сделает автоматически. \
Подпись в сертификате обычно делеается закрытым ключом специального центра сертификации (CA), а подтверждается подпись, соответственно, парным открытым ключом этого же CA. Этот открытый ключ находится в сертификате CA -- такие сертификаты называются корневыми и по умолчанию установлены в операционной системе (мы им доверяем по умолчанию).\
Однако, чтобы тут не возиться с ними, мы делаем так называем самоподписанный сертификат: сертификат сервера подписывается закрытым ключом этого же сервера. Тогда для проверки сертификата достаточно знать открытый ключ сервера (он, конечно, написан в предоставленном сертификате, но так как мы ещё не проверили его, этот ключ нужно знать заранее) -- его мы просто подсовываем клиенту заранее (просто весь сертификат сервера подсовываем сразу: то есть в данном случае сертификат сервера выступает в роли корневого для самого себя). Это никак не портит безопасность, но на практике делают через CA, так как непонятно, как безопасно (без возможности подмены) клиент может узнать сертификат сервера (в данном случае мы этот сертификат, можно сказать, вписываем вручную на стороне клиента)... а вот сертификатов CA не так много -- их заранее сохраняют в операционной системе.

Это было про аутентификацию сервера. Клиент тоже может подтверждать свою подлинность с помощью сертификата, но обычно это делается с помощью логина-пароля уже на этапе общения между клиентом и сервером.

То, насколько важен сертификат, можно убедиться с помощью атаки MIM (Man-in-the-middle).

#### Требования:
1. Операционная система Linux
2. Установленные библиотеки openssl, libcrypto и lm.

При разработке я использовал версию 3.0:
```console
vselenaya@computer:~$ openssl version
OpenSSL 3.0.2 15 Mar 2022 (Library: OpenSSL 3.0.2 15 Mar 2022)
```
#### Подготовка к использованию:
Как было сказано, для аутентификации сервера, нужно сгенерировать закрытый ключ сервера (его будет знать только сервер) и самоподписанный (то есть подписанный этим же закрытым ключом) сертификат сервера (его сервер будет посылать клиенту для аутентификации и его же заранее будет иметь клиент у себя, чтобы вытащить из него открытый ключ и им проверить присланный якобы от сервера сертификат).\
Это можно сделать через команду `make cert_server` (внутри используются команды *openssl*).

Для сборки проекта, можно воспользоваться командами: `make client` и `make server`. Они соберут исполняемые файлы `client` клиента и `server` сервера.

#### Запуск и использование:
1. Сначала нужно запустить серверное приложение: `./server`. После этого сервер начнёт ждать подключения от клиента.
2. Далее запускаем (в отдельном окне терминала Linux) клиентское приложение: `./client`. 
3. Если всё настроено правильно и сертификат правильный, то TLS-подключение создастся автоматически. После этого у клиента появится приглашение к вводу сообщения для сервера.
4. Далее, начиная с клиента, сервер и клиент могут обмениваться сообщениями по сети, вводя их с клавиатуры. При этом безопасность общения обеспечивается протколом TLS. Заметим, что сообщения отправляются по очереди: сначала клиент отправляет (а сервер просто ждёт и ничего не пишет), затем сервер получает и пишет ответ (до получения овтета клиент ждёт и ничего не пишет).
5. Для прекращения диалога, клиент или сервер вводят сообщение *EXIT*. При этом клиентское приложение завершает работу, а серверное заканчивает диалог с данным клиентом и вновь готов соединяться с новыми клиентами.


#### Демонстрация работы для обмена сообщениями:

Вывод клиента:
```console
vselenaya@computer:~/socket3$ ./client
ЗАПУСК КЛИЕНТА
=============
Контекст клиента для работы ssl загружен...
Есть соединение с сервером...
Соединение с TLS_AES_256_GCM_SHA384 криптографией...

Сертификат сервера успешно принят:
Сертификат подключенного собеседника
Subject: /C=RU/ST=Some-State/L=SPB/O=SPBU_NET/CN=localhost
Issuer: /C=RU/ST=Some-State/L=SPB/O=SPBU_NET/CN=localhost

=== TLS соединение успешно установлено ===

Введите сообщение для сервера (EXIT - выход):
Привет!       
--> Отправили сообщение для сервера

Ответ сервера:
Привет! Как дела?
Введите сообщение для сервера (EXIT - выход):
Неплохо! Реши задачку, пожалуйста: 123+45=?
--> Отправили сообщение для сервера

Ответ сервера:
Хммм, кажется 168
Введите сообщение для сервера (EXIT - выход):
Ага, правильно!
--> Отправили сообщение для сервера

Ответ сервера:
Здорово. Давай тогда пока)
Введите сообщение для сервера (EXIT - выход):
EXIT
vselenaya@computer:~/socket3$ 
```

Вывод сервера:
```console
vselenaya@computer:~/socket3$ ./server
ЗАПУСК СЕРВЕРА
=============
Контексты и сертификаты сервера для работы ssl загружены...
Серверный сокет открыт...

Ждём клиентов...
Принято соединение от клиента: 127.0.0.1:45032
Соединение с TLS_AES_256_GCM_SHA384 криптографией...

=== TLS соединение успешно установлено ===

...ждём сообщений от клиента...

Cообщение от клиента:
Привет!
Введите сообщение клиенту (EXIT - выход)...
Привет! Как дела?
---> сообщение клиенту отправлено

Cообщение от клиента:
Неплохо! Реши задачку, пожалуйста: 123+45=?
Введите сообщение клиенту (EXIT - выход)...
Хммм, кажется 168
---> сообщение клиенту отправлено

Cообщение от клиента:
Ага, правильно!
Введите сообщение клиенту (EXIT - выход)...
Здорово. Давай тогда пока)
---> сообщение клиенту отправлено

Клиент завершил диалог.

Ждём клиентов...

```
Как можно заметить, сервер не завершил работу, а ждёт подключения от других клиентов.

#### Проверка скорости:
Проект позволяет протестировать скорость создания TLS-соединения и скорость отправки сообщений. Для этого необходимо запустить сервер и клиент с параметром `test_speed`. В этом случае сервер выключит вывод всех функций (чтобы не засорять вывод огромным количеством справочной информации), а клиент замерит скорость создания TLS-соединения с сервером, а также скорость обмена парой сообщений (время между началом отправки сообщения на сервер и окончанием получения ответа от сервера (при тестировании скорости сервер работает в режиме эхо: то есть посылает клиенту те же сообщения, что клиент отправил ему; клиент же посылает случайно сгенерированные сообщения)).

Количество итераций тестирования задаётся параметром `TEST_ITERS` в файле `common.h`. Аккуратнее: при тестировании скорости создания соединения в коде есть *sleep* на 1.5 секунды (чтобы дождаться завершения соединения на сервере). Поэтому время тестирования скорости соединения будет как минимум $TEST\_ITERS \cdot 1.5$ секунд.

#### Демонстрация работы тестирования скорости:
Вывод сервера:
```console
vselenaya@computer:~/socket3$ ./server test_speed
Запуск в режиме тестирование скорости
(вывод всех дальнейших функций отключён)
vselenaya@computer:~/socket3$ 
```
заметим, что в данном режиме по окончании тестирования, сервер тоже завершает работу.

Вывод клиента:
```console
vselenaya@computer:~/socket3$ ./client test_speed
Начинаем тестирование скорости...
Скорость создания TLS-сессии:
    средняя скорость: 0.007788
    стандартное отклонение: 0.001721
    количество итераций: 100

Скорость обмена парой сообщений (длины 1000 байт):
    средняя скорость: 0.000263
    стандартное отклонение: 0.000025
    количество итераций: 100

vselenaya@computer:~/socket3$ 
```
под скоростью имеется в виду время - в секундах.

#### Реализация атаки MIM:
Под атакой MIM (Man-in-the-middle или человек посередине) подразумевается атака, при которой некоторое приложение встаёт между клиентом и сервером. Это приложение незаметно подменяет сервер для клиента и клиента для сервера (то есть mim является одновременно и клиентом, и сервером - и, конечно, у него есть свой сертификат). Таким образом, клиент и сервер думают, что общаются друг с другом, а на самом деле они общаются через приложение mim, которое может читать все сообщения (нарушается конфиденциальность), может видоизменять, удалять добавлять новые и так далее (нарушается целостность). Именно сертификат сервера должен защищать от такой атаки клиента (сервера от этого защищает аутентификация, например, по логину-паролю клиента).

В данном проекте эта атака реализована следующим образом: клиент подключается к приложению mim, а приложение mim подключается к серверу. Далее общение клиента и сервера происходит как и ранее, но теперь приложение mim выводит на экран каждое сообщение и предоставляет возможность изменить его.

Клиент может попасться на атаку MIM только, если он ошибочно примет за настоящий сервер приложение mim. Как мы знаем, в нашей реализации аутентификация сервера производится с помощью открытого ключа, находящегося в сертификате, который заранее знает клиент. Поэтому для реализации атаки MIM, нужно внутри кода клиента подменить сертификат сервера на сертификат mim (в реальном мире атака MIM производится если, например, у пользователя был установлен чужеродный корневой сертификат, который подтвердит подлинность какого-нибудь сайта мошенников вместо настоящего сайта...).\
А также, конечно, необходимо явно указать в коде клиента адрес приложения mim, к которому подключаться (в реальности адрес, к которому подключается пользователь подменяется или подменой DNS-ответа, или же просто специальной настройкой маршрутизаторов, которые ведут запрос на сайт мошенников).

Итак, для реализации атаки MIM в проекте, необходимо:
1. Сгенерировать сертификат и закрытый ключ приложения mim: `make cert_mim`. После этой команды появятся файлы `mim_cert.pem` (сам сертификат) и `mim_private.key` (приватный ключ - его знает и использует только само приложение mim).
2. Собрать приложение: `make mim` -- эта команда скомпилирует программу `mim`, которое и будет реализовыввать атаку MIM.
3. Подменить явно в коде клиента (в файле `client.c`) адрес (а точнее - доменное имя)сервера на адрес mim (при запуске на одном и том же компьютере mim будет работать по адресу `localhost`; порт, на котором будет запущен mim (если в его код не вносилисб изменения) - это `9091`).\
Для этого нужно заменить строки `21-23` файла `client.c` с таких:
```c
#define SERVER_ADDR "localhost"  // адрес, где работает сервер
#define SERVER_PORT 4433  // порт, где рабоатет сервер
#define CERT_FILE "server_cert.pem"  // сертификат сервера (по открытом ключу этого сертификата проверяется подлинность сервера)
```
на такие:
```c
#define SERVER_ADDR "localhost"  // адрес mim
#define SERVER_PORT 9091  // заменили порт, куда подключаться клиенту, на порт mim
#define CERT_FILE "mim_cert.pem"  // явно указали сертификат mim
```

4. После изменения кода клиента, нужно не забыть перекомпилировать: `make client`
5. Запускаем сначала сервер: `./server`, затем приложение mim: `./mim`, и потом клиент: `./client`.

#### Демонстрация атаки MIM:
Вывод сервера:
```console
vselenaya@computer:~/socket3$ ./server
ЗАПУСК СЕРВЕРА
=============
Контексты и сертификаты сервера для работы ssl загружены...
Серверный сокет открыт...

Ждём клиентов...
Принято соединение от клиента: 127.0.0.1:44722
Соединение с TLS_AES_256_GCM_SHA384 криптографией...

=== TLS соединение успешно установлено ===

...ждём сообщений от клиента...

Cообщение от клиента:
Привет! Реши пример 100+20=?
Введите сообщение клиенту (EXIT - выход)...
Привет! Ответ 120
---> сообщение клиенту отправлено

Cообщение от клиента:
А вот и неверно!

Введите сообщение клиенту (EXIT - выход)...
EXIT

Ждём клиентов...

```
Вывод клиента:
```console
vselenaya@computer:~/socket3$ ./client
ЗАПУСК КЛИЕНТА
=============
Контекст клиента для работы ssl загружен...
Есть соединение с сервером...
Соединение с TLS_AES_256_GCM_SHA384 криптографией...

Сертификат сервера успешно принят:
Сертификат подключенного собеседника
Subject: /C=RU/L=SPb/O=SPbU/CN=spbu.ru
Issuer: /C=RU/L=SPb/O=SPbU/CN=spbu.ru

=== TLS соединение успешно установлено ===

Введите сообщение для сервера (EXIT - выход):
Привет! Реши пример 100+20=?
--> Отправили сообщение для сервера

Ответ сервера:
Не хочу решать пример!

Введите сообщение для сервера (EXIT - выход):
Ну и не надо. Я обиделся.
--> Отправили сообщение для сервера

Сервер закончил диалог.
vselenaya@computer:~/socket3$ 
```
Как можно заметить, клиент получил сообщения не те, которые отправлял сервер. Дело в mim, который напакостил и обидел клиента...

Вывод mim:
```console
vselenaya@computer:~/socket3$ ./mim
MIM удалось подключиться к серверу!
Сертификат подключенного собеседника
Subject: /C=RU/ST=Some-State/L=SPB/O=SPBU_NET/CN=localhost
Issuer: /C=RU/ST=Some-State/L=SPB/O=SPBU_NET/CN=localhost
TLS-соединение с СЕРВЕРОМ успешно установлено
К MIM подключился клиент: 127.0.0.1:57650!
TLS-соединение с КЛИЕНТОМ успешно установлено

=== MIM-атака готова! ===

КЛИЕНТ пытается отправить серверу сообщение:
Привет! Реши пример 100+20=?
Разрешить передачу (1 или 0)?
1
сообщение не модифицируем.
--> Отправили сообщение для сервера

СЕРВЕР пытается отправить клиенту сообщение:
Привет! Ответ 120
Разрешить передачу (1 или 0)?
0
Введите новое сообщение:
Не хочу решать пример!
--> Отправили сообщение для клиента

КЛИЕНТ пытается отправить серверу сообщение:
Ну и не надо. Я обиделся.
Разрешить передачу (1 или 0)?
0
Введите новое сообщение:
А вот и неверно!
--> Отправили сообщение для сервера

СЕРВЕР завершил передачу.
vselenaya@computer:~/socket3$ 
```


#### Особенности реализации:
данный проект всё же учебный, поэтому тут есть несколько недостатков...
1. Размер всех сообщений не должен быть больше `BUFFER_LEN`, который установлен в 1024 байт.
2. Для отправки/получения сообщений из TLS-сокета, используются просто команды `SSL_read` (аналог команды `recv` в обычном сокете) и `SSL_write` (аналог `send` в обычном сокете).\
Чтобы сообщения не смешивались, при оправке каждого сообщения сначала отправляется ровно 8 байт числа типа `size_t`: длина последующего сообщения. Тогда при получении мы точно знаем, что сначала идут эти 8 байт, а потом ещё нужно считать сообщение ровно той длины, сколько написано в полученнх 8 байтах. Это общепринятый способ отправки-получения сообщений в реальных приложениях.\
Но по-хорошему, при получении сообщений нужно не просто считывать через один вызов `SSL_read` или `recv`, это нужно делать в цикле `while` (так как отправленные, например, 1024 байта, могут дойти до адресата кусками: сначала 512 байтов, затем 256, затем оставшиеся 256... и всё это адресат должен считать): то есть сначала нужно считывать сокет пока не наберём 8 байтов (в которых лежит длина последующего сообщения), а затем нужно читать из сокета, пока не набеёрм указанную ранее длину сообщения. Конечно, чтобы не зависнуть при чтении из сокета (если данных в сокете нет, то и `recv`, и `SSL_write` просто зависнут в ожидании данных... а такое может быть: если клиент отправил случайно данные в неправильном формате, то мы можем недочитать или наоборот ждать данных, которых не будет тд), необходимо установить таймаут на чтение.\
Но так как этот проект всё же больше про криптографию, этого не сделано, но можно быстро поправить.
3. При любых ошибках (неправильный сертификат или осутсвтие файла...), программа будет просто падать (завершаться с ненулевым кодом возврата, не заботясь об очистке памяти), но во многих случаях информация об ошибке будет выведена. В принципе, это не страшно, так как при завершении программы операционная система сама освободит всю память и закроет все сокеты.\
При корректной работе программы утечек памяти быть не должно.
